<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero Monopoly 3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="estilo.css">
</head>
</head>
<body>
    <a href="cubo.html" class="btn">Prueba de Cubo</a>
    <script>
        // Crear escena, cámara y renderizador
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Posición inicial de la cámara
camera.position.set(0, 10, 10);
camera.lookAt(0, 0, 0);

// Crear el tablero (Plano base)
const tableroGeometry = new THREE.PlaneGeometry(10, 10);
const tableroMaterial = new THREE.MeshBasicMaterial({ color: 0x008000, side: THREE.DoubleSide });
const tablero = new THREE.Mesh(tableroGeometry, tableroMaterial);
tablero.rotation.x = -Math.PI / 2; // Girar para que quede plano
scene.add(tablero);

// Datos de las casillas
const casillasNombres = [
    "Inicio", "Mediterranean Ave", "Comunidad 1", "Baltic Ave", "Impuesto 1",
    "Estación 1", "Oriental Ave", "Suerte 1", "Vermont Ave", "Connecticut Ave",
    "Cárcel", "St. Charles Place", "Electricidad", "States Ave", "Virginia Ave",
    "Estación 2", "St. James Place", "Comunidad 2", "Tennessee Ave", "Nueva York Ave",
    "Parking Libre", "Kentucky Ave", "Suerte 2", "Indiana Ave", "Illinois Ave",
    "Estación 3", "Atlantic Ave", "Ventnor Ave", "Agua", "Marvin Gardens",
    "Ve a la Cárcel", "Pacific Ave", "North Carolina Ave", "Comunidad 3", "Pennsylvania Ave",
    "Estación 4", "Suerte 3", "Park Place", "Impuesto 2", "Boardwalk"
];

// Crear las casillas
const casillas = [];
const casillasGroup = new THREE.Group();
const casillaSize = 1;
let index = 0;

for (let i = 0; i < 10; i++) {
    // Parte inferior del tablero
    crearCasilla(i - 4.5, -4.5, casillasNombres[index++]);
}
for (let i = 1; i < 10; i++) {
    // Lado derecho
    crearCasilla(4.5, i - 4.5, casillasNombres[index++]);
}
for (let i = 1; i < 10; i++) {
    // Parte superior
    crearCasilla(4.5 - i, 4.5, casillasNombres[index++]);
}
for (let i = 1; i < 9; i++) {
    // Lado izquierdo (sin repetir esquina)
    crearCasilla(-4.5, 4.5 - i, casillasNombres[index++]);
}

// Agregar las casillas a la escena
scene.add(casillasGroup);

function crearCasilla(x, y, nombre) {
    const geometry = new THREE.BoxGeometry(casillaSize, 0.2, casillaSize);
    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const casilla = new THREE.Mesh(geometry, material);
    casilla.position.set(x, 0.1, y);
    casilla.userData = { nombre };
    casillas.push(casilla);
    casillasGroup.add(casilla);
}

// Raycaster para detectar clics
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Evento de clic para detectar casillas seleccionadas
window.addEventListener("click", (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(casillas);

    if (intersects.length > 0) {
        const casillaSeleccionada = intersects[0].object;
        alert(`Casilla seleccionada: ${casillaSeleccionada.userData.nombre}`);
        casillaSeleccionada.material.color.set(0xff0000);
    }
});

// Variables para la rotación de la cámara con el mouse
let isMouseDown = false;
let previousMousePosition = { x: 0, y: 0 };

// Eventos para detectar cuándo el mouse está presionado
window.addEventListener("mousedown", () => isMouseDown = true);
window.addEventListener("mouseup", () => isMouseDown = false);

// Evento para rotar la cámara con el mouse
window.addEventListener("mousemove", (event) => {
    if (isMouseDown) {
        const deltaX = event.clientX - previousMousePosition.x;
        const deltaY = event.clientY - previousMousePosition.y;

        // Rotación horizontal (eje Y)
        camera.rotation.y -= deltaX * 0.002;

        // Rotación vertical (eje X)
        camera.rotation.x -= deltaY * 0.002;
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x)); // Limitar rotación vertical
    }

    previousMousePosition = { x: event.clientX, y: event.clientY };
});

// Movimiento de la cámara relativo a su orientación
const moveSpeed = 0.5;
const keys = { w: false, a: false, s: false, d: false };

// Eventos de teclado (sin cambios)
window.addEventListener("keydown", (event) => {
    if (event.key === 'w') keys.w = true;
    if (event.key === 'a') keys.a = true;
    if (event.key === 's') keys.s = true;
    if (event.key === 'd') keys.d = true;
});

window.addEventListener("keyup", (event) => {
    if (event.key === 'w') keys.w = false;
    if (event.key === 'a') keys.a = false;
    if (event.key === 's') keys.s = false;
    if (event.key === 'd') keys.d = false;
});

// Función para mover la cámara (CORREGIDA)
function moveCamera() {
    // Obtener vectores de dirección desde la matriz de la cámara
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();
    
    // Extraer direcciones desde la matriz de la cámara
    camera.matrixWorld.extractBasis(right, new THREE.Vector3(), forward);
    forward.normalize();
    right.normalize();

    // Aplicar movimiento
    if (keys.w) camera.position.add(forward.multiplyScalar(-moveSpeed)); // Adelante
    if (keys.s) camera.position.add(forward.multiplyScalar(moveSpeed));  // Atrás
    if (keys.a) camera.position.add(right.multiplyScalar(-moveSpeed));   // Izquierda
    if (keys.d) camera.position.add(right.multiplyScalar(moveSpeed));    // Derecha
}

// Animación (sin cambios)
function animate() {
    requestAnimationFrame(animate);
    moveCamera();
    renderer.render(scene, camera);
}
animate();
    </script>
</body>
</html>
